<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="description" content="Uebersicht der Motorregelung des c't-Bots" />
<meta name="author" content="Timo Sandmann" />
<meta name="keywords" content="c't-Bot,speedcontrol,Motorregelung,pid" />
<meta name="date" content="2007-04-04" />
<title>c't-Bot - Motorregelung</title>
<link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
<h1>Dokumentation zur Motorregelung</h1>
<br />

<a class="menu" href="#uebersicht">Eine allgemeine &Uuml;bersicht</a><br />
<a class="menu" href="#details">Die Motorregelung im Detail</a>
<ul>
    <li><a class="menu" href="#params">Die Parameter</a></li>
    <li><a class="menu" href="#pid">Die eigentliche Regelung</a></li>
    <li><a class="menu" href="#sensor">Die Sensorauswertung</a></li>
    <li><a class="menu" href="#adjust">Finden und Einstellen der richtigen Parameter</a></li>
    <li><a class="menu" href="#log">Die Logging-Funktion</a></li>
</ul>

<a name="uebersicht"></a><h2>Eine allgemeine &Uuml;bersicht</h2>
<p>Die Ansteuerung der Motoren funktioniert wie folgt:<br />
Die Funktion<span class="function"> motor_set(int16 left, int16 right)</span> setzt die gew&uuml;nschte Sollgeschwindigkeit (F&uuml;hrungsgr&ouml;&szlig;e). Ist diese f&uuml;r
mindestens einen Motor ungleich Null, k&uuml;mmert sich die Funktion<span class="function"> speed_control()</span> um die Einhaltung der
Geschwindigkeit. Wurde eine neue Sollgeschwindigkeit vorgegeben und war au&szlig;erdem die vorherige Geschwindigkeit gleich Null (Anfahren aus dem 
Stand), so sorgen<span class="function"> motor_set()</span> und<span class="function"> speed_control()</span> f&uuml;r ein zun&auml;chst
langsames Anfahren (Hintergrund ist das relativ geringe Drehmoment zu diesem Zeitpunkt, eine genauere Erkl&auml;rung hierzu findet sich 
unter <a href="#pid">Die eigentliche Regelung</a>). Die Istgeschwindigkeit (Regelgr&ouml;&szlig;e) des Bots wird mit den Radencodern gemessen, indem die
seit der letzten (bzw. vor- oder viertletzten, siehe auch <a href="#sensor">Die Sensorauswertung</a>) Encoderflanke vergangene Zeit berechnet wird.<br />
Ist die Regelung aktiv (also das #define<span class="function"> SPEED_CONTROL_AVAILABLE</span> in ct-Bot.h an), werden die Motoren mit einer wesentlich
h&ouml;heren PWM-Frequenz angesteuert (31.200 Hz anstatt 120 Hz), was erstens den Verschlei&szlig; der Motorb&uuml;rsten deutlich reduziert und zweitens
f&uuml;r ein eleganteres Fahrverhalten des Bots sorgt.<br />
Die besten (je kleiner die letzten Fehler waren, desto besser ist das Rating der Werte) PWM-Stellwerte zum Anfahren werden im EEPROM gespeichert, um ein 
m&ouml;glichst sofortiges (und somit f&uuml;r beide R&auml;der gleichzeitiges) Anfahren zu erm&ouml;glichen.</p>
<p>Wer sich nicht f&uuml;r die internen Details der Regelung interessiert, sollte aber zumindest den kompletten Abschnitt <a href="#adjust">
Finden und Einstellen der richtigen Parameter</a> lesen, um die Regelung korrekt einzustellen.</p>

<a name="details"></a><h2>Die Motorregelung im Detail</h2>
<a name="params"></a><h3>Eine &Uuml;bersicht aller Konfigurationsparameter</h3>
<p>Folgende Parameter der Regelung lassen sich in <a href="../include/bot-local.h">include/bot-local.h</a> einstellen:</p>
<ul>
    <li><span class="function"> PID_Kp</span> Der proportionale Anteil des PID-Reglers. Er gibt an, wie stark sich der aktuelle Fehler auf die
    Korrektur der Geschwindigkeit auswirkt. Hier ist in der Regel ein relativ hoher Wert sinnvoll, zugelassen sind Werte von 0 (schaltet den
    P-Anteil komplett aus) bis 127.</li>
    <li><span class="function"> PID_Ki</span> Der integrale Anteil des PID-Reglers. Er gibt an, wie stark sich die Summe der letzten Fehler auf
    die Korrektur der Geschwindigkeit auswirkt. Hier ist in der Regel ein eher kleinerer Wert g&uuml;nstig, zugelassen sind Werte von 0 (schaltet
    den I-Anteil komplett aus) bis 127.</li>
    <li><span class="function"> PID_Kd</span> Der differentielle Anteil des PID-Reglers. Er gibt an, wie stark sich die aktuelle &Auml;nderung der
    Geschwindigkeit (also die Beschleunigung) auf die Korrektur auswirkt. Auch hier ist nur ein kleiner Wert passend, zugelassen sind Werte von 0 
    (schaltet den D-Anteil komplett aus) bis 127.</li>
    <li><span class="function"> PID_Ta</span> Die Abtastzeit. Sie gibt das Verh&auml;ltnis zwischen der Zeitspanne, die seit dem letzten 
    Regleraufruf vergangen ist, und der f&uuml;r die Berechnung erwarteten Zeitspanne an. Normalerweise braucht man hier nichts &auml;ndern und 
    l&auml;sst den Wert auf 1.</li>
    <li><span class="function"> PID_SHIFT</span> Der Divisor der Korrektur. Er gibt an, durch welchen Wert die berechnete &Auml;nderung
    geteilt wird. Anzugeben ist hier der Logarithmus zur Basis 2 (die Division erfolgt durch Bit-Shifting). Damit wird eine m&ouml;glichst
    genaue Einstellung von PID_Kp, PID_Ki und PID_Kd erm&ouml;glicht.</li>
    <li><span class="function"> PID_TIME</span> Das Zeitintervall, nach dem der Regler sp&auml;testens aufgerufen wird in Millisekunden. 
    Wurde nach dieser Zeit keine Encoderflanke registriert, wird von Stillstand ausgegangen. Hier sollte man sich an dem Defaulwert 
    orientieren, Feintuning verbessert evetuell das Verhalten bei sehr kleinen Geschindigkeiten. Zugelassen sind Werte von 0 (das ist aber
    nicht sinnvoll!) bis 655.</li>    
    <li><span class="function"> PID_SPEED_THRESHOLD</span> Die (Soll-)Geschwindigkeit, ab der die Berechnung der Istgeschwindigkeit per
    Interpolation zwischen mehreren Messwerten erfolgt. Sinvoll sind hier BOT_SPEED_SLOW, BOT_SPEED_FOLLOW oder BOT_SPEED_MEDIUM. Detaillierte 
    Informationen finden sich im Erkl&auml;rungstext.</li>     
    <li><span class="function"> PWMMAX</span> Maximaler PWM-Wert. Normalerweise nicht zu ver&auml;ndern.</li>
    <li><span class="function"> PWMMIN</span> Minimaler PWM-Wert. Normalerweise nicht zu ver&auml;ndern.</li>
    <li><span class="function"> PWMSTART_L</span> PWM-Startwert f&uuml;r den linken Motor. Hier sollte man einstellen, ab wann der Motor zu drehen 
    beginnt (unter Last, nicht im Leerlauf).</li>   
    <li><span class="function"> PWMSTART_R</span> PWM-Startwert f&uuml;r den rechten Motor. Hier sollte man einstellen, ab wann der Motor zu drehen 
    beginnt (unter Last, nicht im Leerlauf).</li>   
    <li><span class="function"> PID_START_DELAY</span> Dauer der Anfahrverz&ouml;gerung in Anzahl von Regleraufrufen. Ein kleiner Wert sorgt f&uuml;r
    schnelleres Anfahren, vermindert aber die Stabilit&auml;t der Regelung. Sinnvolle Werte liegen zwischen 10 und 30.</li> 
    <li><span class="function"> ENC_CORRECT_L</span> Korrektur der vom linken Encoder gemessenen Geschwindigkeit in mm/s, falls die Sollgeschwindigkeit
    kleiner als PID_SPEED_THRESHOLD ist. Da das Messverhalten der Radencoder nicht symmetrisch ist, kommt es zu falschen Geschwindigkeitsdaten, 
    wenn die Zeit zwischen zwei direkt aufeinander folgenden Flanken gemessen wird. Um den hier angegebenen Wert wird die errechnete Geschwindigkeit
    korrigiert, falls der Encoderpegel der letzten Flanke HIGH war, anderfalls wird um das Inverse korrigiert. Sinvoll sind Werte zwischen
    -15 und +15.</li>   
    <li><span class="function"> ENC_CORRECT_R</span> Korrektur der vom rechten Encoder gemessenen Geschwindigkeit in mm/s.</li>
</ul>

<a name="pid"></a><h3>Die eigentliche Regelung</h3>
<p>Die Motorregelung basiert auf einem gew&ouml;hnlichen PID-Regler. Dieser ist in der Funktion<span class="function"> 
speed_control(uint8 dev, int16* actVar, uint16* encTime, uint8 i_time, uint8 enc)</span> implementiert. Diese Funktion wird an zwei Stellen
aufgerufen: Erstens aus<span class="function"> bot_encoder_isr()</span> heraus, wenn dort eine neue Flanke eine Radencoders festgestellt wurde
und zweitens aus<span class="function"> bot_sens_isr()</span> heraus, falls in den letzten<span class="function"> PID_TIME</span> ms keine Flanke 
registriert wurde. Letzteres deshalb, damit ein Stillstand des Bots nicht zum Verhungern des Reglers f&uuml;hrt. <br />
Wird durch den Aufruf von<span class="function"> motor_set()</span> eine neue Sollgeschwindigkeit gesetzt, sind zwei F&auml;lle zu unterscheiden: <br />
1.) Die vorherige Geschwindigkeit war gleich Null, es liegt also ein Anlaufen des jeweiligen Rades vor. In diesem Fall ist die Sollgeschwindigkeit 
zun&auml;chst immer<span class="function"> BOT_SPEED_SLOW</span> (oder -<span class="function">BOT_SPEED_SLOW</span>) und wird in den n&auml;chsten
<span class="function"> PID_START_DELAY</span> Regleraufrufen schrittweise auf die gew&uuml;nschte Sollgeschwindigkeit erh&ouml;ht. Hierdurch
wird einerseits eine einheitliche Behandlung des Anlauf-Falls erm&ouml;glicht, was die Codekomplexit&auml;t deutlich reduziert und andererseits
ein (nahezu) ruckfreies Anfahren des Bots erreicht (ist der Verlauf der Geschwindigkeit eine Sinusfunktion, so ist die Beschleunigung (1. Ableitung)
eine Cosinusfunktion und der Ruck (2. Ableitung) wieder eine Sinusfunktion - wir arbeiten auf R&uuml;cksicht der fehlenden FPU der MCU allerdings
nicht mit Sinus, sondern nur mit einer groben N&auml;herung). <br />
2.) Die vorherige Geschwindigkeit war ungleich Null, das Rad ist also bereits in Bewegung. In diesem Fall entfallen die unter 1.) beschriebenen
Spezialf&auml;lle vollst&auml;ndig und der Regler nimmt einfach die neue Sollgeschwindigkeit als F&uuml;hrungsgr&ouml;&szlig;e, den Rest &uuml;bernimmt
der Code automatisch.
</p>

<a name="sensor"></a><h3>Die Sensorauswertung</h3>
<p>Zur Berechnung der aktuellen Geschwindigkeit werden die Radencoder benutzt. Das Messverfahren f&uuml;r die Motorregelung weicht von der allgemeinen
Geschwindigkeitsberechnung des Bots aus zwei Gr&uuml;nden ab: Erstens ist die per<span class="function"> sensor_update()</span> berechnete 
Geschwindigkeit f&uuml;r die Regelung zu ungenau und erfolgt zweitens viel zu selten. Eine schnelle Regelung erfordert das Vorhandensein wirklich
aktueller und zu garantierten Zeiten bereitstehenden Geschwindigkeitsdaten. Berechnet wird die Geschwindigkeit des jeweiligen Rades aus der 
Zeitdifferenz zweier Encoderflanken. Hierbei ist zu beachten, dass zwei direkt aufeinander folgende Flanken unterschiedlicher Natur sind - war die 
Letzte eine steigende Flanke, so muss die N&auml;chste zwangsl&auml;ufig eine Fallende sein und umgekehrt. Die Radencoder registrieren die Flanken
in Abh&auml;ngigkeit der Lichtreflexion der Encoderscheiben, was zur Folge hat, dass bei konstanter Drehgeschwindigkeit des Rades die Zeitspanne 
zwischen einer Steigenden und einer fallenden Flanke nicht gleich der Zeitspanne zwischen einer Fallenden und einer steigenden Flanke sein muss. 
Zwischen Flanken gleicher Art vergeht jedoch bei konstanter Geschwindigkeit immer gleich viel Zeit. Hieraus ergibt sich folgende Konsequenz: 
Entweder zieht man zur Berechnung der Geschwindigkeit jeweils nur Flanken gleicher Art heran, oder man korrigiert die Ungleichheit der Zeitdifferenzen
per Software. Ersteres sorgt f&uuml;r eine deutlich langsamere Geschwindigkeitserfassung, Letzteres f&uuml;r komplexeren Code und mehr 
Konfigurationsparameter. Da bei hohen Geschwindigkeiten sehr oft eine Flanke der Encoder eintrifft, verwendet der Regelungscode das erstgenannte
Verfahren, falls die Sollgeschwindigkeit gr&ouml;&szlig;er als<span class="function"> PID_SPEED_THRESHOLD</span> ist. Au&szlig;erdem wird die Geschwindkeit
aus den letzten vier Encoderflanken berechnet, wenn die Sollgeschwindigkeit gr&ouml;&szlig;er als 2*<span class="function">PID_SPEED_THRESHOLD</span>
ist, um Ungenauigkeiten zu vermeiden, wenn das Zeitintervall zwischen zwei Flanken auf Grund der hohen Geschwindigkeit sehr klein ist. F&uuml;r
langsame Geschwindigkeiten erweist sich das Verfahren allerdings als zu tr&auml;ge, deshalb wird bei Geschwindigkeiten unterhalb von<span class="function"> 
PID_SPEED_THRESHOLD</span> mit jeder Encoderflanke gerechnet und die gemessene Geschwindigkeit um den Betrag<span class="function"> ENC_CORRECT_L</span>
bzw.<span class="function"> ENC_CORRECT_R</span> korrigiert.<br />
Eine (noch) genauere Messung der Geschwindigkeiten ist mit einem kleinen Hardwareumbau zu erreichen: Dreht man die Radencoder um 90 Grad, so
wird das Symmetrieverhalten wesentlich besser und die Zeitspanne zwischen zwei direkt aufeinander folgenden Flanken ist bei konstanter 
Geschwindigkeit immer nahezu gleich. Dadurch kann auch eine Geschwindigkeit von nur 30 mm/s noch ausreichend gut eingeregelt werden (<span class="function"> BOT_SPEED_MIN</span>
in <a href="../include/motor.h">include/motor.h</a> anpassen!). Wer den Umbau der Radencoder nicht scheut, kann dann<span class="function"> ENC_CORRECT_L</span> und<span class="function"> 
ENC_CORRECT_R</span> auf Null setzen, da die Rohdaten der Encoder bereits eine genaue Geschwindigkeitsmessung erm&ouml;glichen.
</p>

<a name="adjust"></a><h3>Finden und Einstellen der richtigen Parameter</h3>
<p>Das Wichtigste f&uuml;r eine gut funktionierende Regelung sind die passenden Parameter Kp, Ki und Kd. Allerdings ist das Berechnen nicht
ganz einfach. Deshalb gibt es ein kleines Verhalten, das automatisch versucht die besten Parameter zu finden. Um es zu benutzen, sind folgende
Schritte n&ouml;tig:<br />
1.) Einschalten des Verhaltens<span class="function"> BEHAVIOUR_CALIBRATE_PID_AVAILABLE</span> in <a href="../include/bot-logic/available_behaviours.h">include/bot-logic/available_behaviours.h</a>.<br />
2.) Die Funktion<span class="function"> bot_calibrate_pid(Behaviour_t *caller, int16 speed)</span> aufrufen, sehr elegant geht das per Bot-Remote-Call. Alternativ kann man auch einfach eine Taste der 
Fernbedienung f&uuml;r den Aufruf verwenden, wie es bei einigen anderen Verhalten ja auch gemacht ist. Als Parameter<span class="function"> speed</span>
&uuml;bergibt man eine Geschwindigkeit, mit der Kalibriert werden soll,<span class="function"> BOT_SPEED_SLOW</span> eignet sich hier am besten.<br />
Nun f&uuml;hrt der Bot einige Drehungen aus, auf dem Regelungs-Screen im Display sieht man den aktuellen Status und die verbleibende Zeit bis zum Ende 
der Kalibrierung. Dabei werden per LOG Zwischenergebnisse ausgegeben, falls LOG aktiviert ist im Code.<br />
Ist die Kalibrierung beendet, stellt das Verhalten die gefundenen Parameter ein und zeigt sie im Display an. Allerdings werden sie <b>nicht</b> dauerhaft gespeichert,
hierzu &uuml;bertr&auml;gt man sie in <a href="../include/bot-local.h">include/bot-local.h</a> und deaktiviert das Verhalten wieder (ist das Verhalten aktiv, arbeitet die 
Regelung nicht ganz so effizient, weil die Parameter variabel sind).<br />
Hinweis: Der im &uuml;bern&auml;chsten Absatz beschriebene Parameter<span class="function"> PID_SHIFT</span> wird durch das Verhalten nicht ver&auml;ndert, wenn man ihn (leicht!) variiert,
arbeitet das Verhalten also in unterschiedlichen "Regionen", genaueres dazu s.u.<br />
<br />
Alternativ lassen sich die Parameter auch manuell bestimmen, das folgende Einstellverfahren liefert dazu bei vertretbarem Aufwand die besten Ergebnisse: <br />
1.) Zuerst stellt man<span class="function"> PID_Kp</span>,<span class="function"> PID_Ki</span>
 und<span class="function"> PID_Kd</span> in <a href="../include/bot-local.h">include/bot-local.h</a> auf <b>0</b> und aktiviert das #define<span class="function"> 
ADJUST_PID_PARAMS</span> in <a href="../ct-Bot.h">ct-Bot.h</a> sowie<span class="function"> DISPLAY_REGELUNG_AVAILABLE</span> in <a href="../ui/available_screens.h">ui/available_screens.h</a>. 
Flasht man nun das erzeugte hex-File auf den Bot, so gibt es einen Display-Screen f&uuml;r die Regelung, der au&szlig;erdem eine spezielle Tastenbelegung
aktiviert. Die erste Displayzeile stellt Istgeschwindigkeit / Sollgeschwindigkeit dar, die Zweite den Betrag des aktuellen Regelfehlers und die Dritte den zurzeit gestellten
PWM-Wert, jeweils f&uuml;r links und rechts. Die letzte Zeile gibt die derzeit einstellten PID-Parameter aus. <br />
2.) Nun sollte der Bot mit<span class="function"> BOT_SPEED_SLOW</span>, 
also 50 mm/s, auf der Stelle drehen. Das erreicht man am Einfachsten mit der Pfeiltaste links oder rechts auf der Fernbedienung. <br />
3.) Anschlie&szlig;end erh&ouml;ht man schrittweise
Kp mit der Taste 1, bis sich der Bot noch mit ann&auml;hernd konstanter Geschwindigkeit auf der Stelle dreht. Wird Kp zu gro&szlig;, beginnt der Regler zu schwingen und man stellt Kp
mit der Taste 4 wieder etwas zur&uuml;ck, bis das Schwingen aufh&ouml;rt. <br />
4.) Jetzt kann man Ki mit der Taste 2 vergr&ouml;&szlig;ern, der Wert sollte aber deutlich kleiner als Kp bleiben.
Mit der Taste 5 kann man Ki wieder verringern. Mit erh&ouml;htem Ki kann man auch Kp noch ein wenig vergr&ouml;&szlig;ern, da der Regler nun stabiler geworden sein sollte. <br />
5.) Es empfiehlt sich,
w&auml;hrend des Einstellens den Bot ab und zu anzuhalten und das Drehen oder Fahren aus dem Stand von Neuem beginnen zu lassen, um &uuml;berpr&uuml;fen zu k&ouml;nnen, ob der Regler 
auch schnell genug die gew&uuml;nschte Sollgeschwindigkeit einregelt. Hier hilft eventuell der D-Anteil des PID-Reglers, den man mit dem Parameter<span class="function"> PID_Kd</span> aktiviert. 
Taste 3 erh&ouml;ht diesen, Taste 6 verringert ihn. Vorsicht, ist Kd zu gro&szlig;, leidet die Stabilit&auml;t der Regelung darunter.<br />
6.) Hat man die Parameter gefunden, die zum besten Ergebnis f&uuml;hren, so tr&auml;gt man diese in <a href="../include/bot-local.h">include/bot-local.h</a> ein und schaltet das #define
<span class="function"> ADJUST_PID_PARAMS</span> in <a href="../ct-Bot.h">ct-Bot.h</a> wieder aus, damit ein Teil der PID-Regler-Gleichung bereits zur Compilezeit berechnet und der
Mikrocontroller somit entlastet werden kann. </p>
<p>Allgemein gilt f&uuml;r die Parameter: Je gr&ouml;&szlig;er sie sind, desto <i>schneller</i> ist die Regelung, je kleiner sie sind, desto <i>stabiler</i> ist die Regelung. Sollte der 
Wertebereich von 0 bis 127 nicht ausreichen, so kommt der Parameter<span class="function"> PID_SHIFT</span> ins Spiel. Erh&ouml;ht man ihn um eins, so ist das Gleichbedeutend mit der 
Halbierung von Kp, Ki und Kd. Verringert man ihn um eins, so entspricht das der Verdoppelung von Kp, Ki und Kd. F&uuml;r die beste Einstellgenauigkeit w&auml;hlt man also<span 
class="function"> PID_SHIFT</span> so, dass<span class="function"> PID_Kp</span> (sollte den gr&ouml;&szlig;ten Wert unter den Parametern haben) zwischen 64 und 127 liegt.</p>
<p>Da das Einstellen der Parameter etwas knifflig ist, w&auml;re es sch&ouml;n und hilfreich, die eingestellten Parameter ebenso wie weitere Erfahrungen mit der Regelung zu sammeln.
Dazu dazu bietet sich ein Thread im <a href="http://www.heise.de/ct/foren/go.shtml?list=1&amp;forum_id=89813" target="_blank">Forum</a> an. Wenn dann z.B. auf 90% aller Bots die Parameter x, y, z die besten Ergebnisse
liefern, werden dies die Default-Werte im SVN.
</p>

<a name="log"></a><h3>Die Logging-Funktion</h3>
<p>M&ouml;chte man genauer analysieren, wann der Bot wie schnell fuhr und wie exakt die gew&uuml;nschte Geschwindigkeit eingeregelt wurde, kann man daf&uuml;r w&auml;hrend des Fahrens einige
Daten mitloggen lassen, die auf einer MMC oder SD-Karte gespeichtert werden. Dazu aktiviert man das #define<span class="function"> SPEED_LOG_AVAILABLE</span> in <a href="../ct-Bot.h">ct-Bot.h</a>
und stellt au&szlig;erdem sicher, dass <span class="function"> MMC_AVAILABLE</span> und<span class="function"> MINI_FAT_AVAILABLE</span> an sind.<br />
Nun werde einige Daten im Bot-Betrieb gesammelt und automatisch aufgezeichnet. Damit man diese am PC auswerten kann, muss es auf der verwendeten MMC eine Mini-Fat-Datei mit der ID <i>slog</i>
geben, die man mit dem PC-Code des Bots wie folgt erzeugt:<span class="function"> ct-Bot.elf -c /mnt/my_mmc/slog.txt slog 1024</span> bzw.<span class="function"> ct-Bot.exe -c X:\slog.txt slog 1024</span>.<br />
Hat der Bot seine Fahraufgaben beendet, nimmt man die MMC heraus, steckt sie in einen PC und ruft<span class="function"> ct-Bot.elf -l /mnt/my_mmc/slog.txt</span> auf, was die Log-Datei auf der 
MMC aus dem Bot-Format in eine txt-Datei mit dem Namen <i>slog.txt</i> im Arbeitsverzeichnis von ct-Bot.elf konvertiert. Diese kann man entweder mit einem Texteditor seiner Wahl oder - und das
erm&ouml;glicht eine schnelle und anschauliche Auswertung - mit einer Tabellenkalkulation &ouml;ffnen. Die Spalten sind durch Tabs getrennt, der Inhalt der jeweiligen Spalte geht aus der 
&Uuml;berschrift hervor. Der erste / obere Teil der txt-Datei enth&auml;lt die Daten des linken Rades, der Untere die des Rechten. <br />
Man sollte die Tabelle als erstes nach der Spalte <i>Timestamp</i> sortieren, damit die Reihenfolge der Daten korrekt ist. Multipliziert man die Eintr&auml;ge der Spalte <i>Timestamp</i> 
mit 176, so erh&auml;lt man als Einheit Mikrosekunden. Jede g&auml;ngige Tabellenkalkulation stellt die Daten nun mit wenigen Mausklicks als Diagramm dar oder rechnet beliebige Dinge aus.</p>
<p>Es sei noch angemerkt, dass die Priorit&auml;t dieses Log-Verfahrens zum Entstehungszeitpunkt auf Performance lag, um die Laufzeit der Funktionen auf dem Bot m&ouml;glichst unver&auml;ndert 
zu lassen. Au&szlig;erdem ist das Ganze als Debug-Ausgabe w&auml;hrend der Entwicklung entstanden und gl&auml;nzt nicht mit &uuml;ppiger Funktionalit&auml;t oder gar Sch&ouml;nheit. Es ist aber 
auch zum Einstellen und / oder bewerten von Ergebnissen hilfreich und daher im Code geblieben.
</p>

<br /><br />
<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Transitional" height="31" width="88" /></a></p>  
</body>
</html>