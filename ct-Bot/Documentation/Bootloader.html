<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="description" content="Bootloader f&uuml;r den c't-Bot" />
<meta name="keywords" content="c't-Bot,Bootloader" />
<meta name="date" content="2007-01-17" />
<title>Bootloader f&uuml;r den c't-Bot</title>
<link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
	<h1>Bootloader f&uuml;r den c't-Bot</h1>
	
	<p>Wir haben den Bootloader von Martin Thomas (<a href="http://www.siwawi.arubi.uni-kl.de/avr_projects" target="_blank">http://www.siwawi.arubi.uni-kl.de/avr_projects</a>) 
	mit in das c't-Bot-Projekt aufgenommen. Damit dauert das &Uuml;bertragen der Hex-Files gerade noch 14 Sekunden.</p>
	<p>Sowohl f&uuml;r den ATmega32 als auch den ATmega644 ist der Bootloader bereits in den Code integriert. Man muss nur sicherstellen, dass 
	in der Datei ct-Bot.h der Schalter<span class="function"> BOOTLOADER_AVAILABLE</span> aktiviert ist und die Linkereinstellungen passen. 
	</p>

	<p>F&uuml;r den ATmega32 muss man dem Linker 
	<span class="function">-Wl,--section-start=.bootloader=0x7C00</span> und f&uuml;r den ATmega644 
	<span class="function">-Wl,--section-start=.bootloader=0xF800</span> mit auf den Weg geben. Am besten schneidet man sich die Parameter hier per cut'n'paste aus und f&uuml;gt sie in Eclipse unter
	Project->Properties->C/C++-Build->Tool Settings->GCC Linker->Miscellaneous ein:</p>
	<a href="images/eclipse-linker.jpg" onclick="popup=window.open('images/eclipse-linker.jpg','','dependent=yes,location=no,menubar=no,status=no,toolbar=no,scrollbars=yes'); popup.focus(); return false"><img height="200" src="images/eclipse-linker.jpg" alt="" title="klick mich!" /></a>

	<p style="clear:both">Das entstandene Hex-File ct-Bot.hex muss man einmalig mit dem Programmierer der 
	Wahl in den Bot &uuml;bertragen &ndash; genauso wie vorher ohne Bootloader.
	Au&szlig;erdem muss man die Fuse-Bits nun anders setzen: 
	In Ponyprog muss nun ein bei BOOTRST und bei BOOTSZ0 ein H&auml;ckchen sein. 
	Bei BOOTSZ1 darf hingegen keines mehr sein.</p>
	<a href="images/ponyprog_atm32.jpg" onclick="popup=window.open('images/ponyprog_atm32.jpg','','dependent=yes,location=no,menubar=no,status=no,toolbar=no,scrollbars=yes'); popup.focus(); return false"><img height="200" src="images/ponyprog_atm32.jpg" alt="" title="klick mich!" /></a>
	
	<p style="clear:both">Wer statt PonyProg2000 lieber ein Kommandozeilen-Tool verwendet, um die Fuse-Bits zu setzen, findet in diesem Verzeichnis die Hex-Dateien 
		(<a href="../contrib/Bootloader/bootloader_hfuse.hex">bootloader_hfuse.hex</a>, <a href="../contrib/Bootloader/bootloader_lfuse.hex">bootloader_lfuse.hex</a>, 
		<a href="../contrib/Bootloader/bootloader_lock.hex">bootloader_lock.hex</a> und zus&auml;tzlich f&uuml;r den Atmega644 <a href="../contrib/Bootloader/bootloader_m644_efuse.hex">bootloader_m644_efuse.hex</a>) 
		daf&uuml;r, die sich mit den Skripten im <a href="../contrib/flash_n_fuse">flash_n_fuse</a>-Verzeichnis &uuml;bertragen lassen.</p>
	<p style="color:red">Achtung: Um &uuml;ber (W)LAN flashen zu k&ouml;nnen, braucht man mindestens avrdude 5.3. Die avrdude-Version 5.3.1 hat aber ein Problem bei den Fuse Bits im Zusammenhang mit einem Programmer 
		vom Typ avr910, bei diesem Programmer sollte man auf jeden Fall avrdude 5.4 oder neuer benutzen.
	</p>
	<p>Bei Problemen mit dem Flashen neuer Software hilft es oftmals zuvor (einmalig) ein komplettes Chip-Erase durchzuf√ºhren.<br /><br /></p>
		

	<p>Ab jetzt wartet der Bot nach einem Reset 5 Sekunden auf eine eingehende Programmierverbindung.</p>
	
	<p>Nun kann man &uuml;ber eine RS-232- oder eine USB-2-Bot- oder eine LAN-/WLAN- (WiPort)-Verbindung den ATmega32 mit fast jedem beliebigen Programmierprogramm mit Daten bef&uuml;llen. Hier ein paar Beispiele:</p>
	
	<ul>
		<li><b>Netzwerk per WiPort:</b> ./avrdude -p m32 -c avr109 -P net:10.10.22.58:10002 -U flash:w:ct-Bot.hex:i -u</li>
		<li><b>USB-2-Bot auf COM3:</b> ./avrdude -p m32 -c avr109 -P com3 -U flash:w:ct-Bot.hex:i -u -b 57600</li>
		<li><b>USB-2-Bot unter Linux:</b> ./avrdude -p m32 -c avr109 -P /dev/ttyUSB0 -U flash:w:ct-Bot.hex:i -u -b 57600</li>
	</ul>
		
	<p><b>Tipps:</b> </p>
	<ul>
		<li>Wenn man den WiPort verwendet, muss man den Channel 2 
		(Serial Settings) auf 57600 Baud (8N1) stellen. Au&szlig;erdem sollte man sowohl
		 f&uuml;r den Input als auch den Output Buffer jeweils die beiden Optionen 
		"Flush .. With active connect"  und "Flush .. With passive connect" aktivieren.</li>
		<li>Achtung auch der WiPort braucht ein wenig Zeit zum Booten, es kannn also sein, dass er nicht gleich nach dem Power-on reagiert.</li>
		<li>Wenn man RS-232- oder USB-2-Bot-Verbindungen nutzt, sollte man unter Windows den COM-Port auf 57600 Baud (8N1) einstellen</li>
	</ul>
	<a href="images/wiport_serialsettings.jpg" onclick="popup=window.open('images/wiport_serialsettings.jpg','','dependent=yes,location=no,menubar=no,status=no,toolbar=no,scrollbars=yes'); popup.focus(); return false"><img height="200" src="images/wiport_serialsettings.jpg" alt="" title="klick mich!" /></a>
</body>
</html>